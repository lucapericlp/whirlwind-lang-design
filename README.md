# A Whirlwind Journey

> normal has been redefined downward so the things we take to be normal, in many ways, are just shadows of better ideas in the past
[Alan Kay 2019](https://www.youtube.com/watch?v=wdHtYW_wcAs&t=1803s)


Through the design space of programming languages as an antidote to the cultural
"pop" nature of software-related communities. Questions of this nature:

- How have or haven't programming languages evolved over time?
- What are some of the productive & counter-productive design principles we've
  seen?
- What are the Lindy features across languages?
- What are some interesting quirks?


# Methodology

Project Euler.

# Revision

Originally, I was intending to grab the dated compilers for each language but
after an initial foreay into Fortran I, I decided it was probably more hassle
than it was worth for a first pass (documentation via manuals). Instead I'll be
taking the modern versions of each language to compare & contrast, where does
each converge & what are the reasons for them? Purely a result of dated legacy
domains in a different ecosystem? Hope is that some Pareto distribution exists
where the majority of the insight is not lost from using the latest compilers.
It will be hard to empirically verify this though given that the only metric will be my
satisfaction with the quality & frequency of insights.

# A Rough Outline

Subject to change whenever & excludes any that I have a sense of their
ergonomics. Each language is prefixed by my enthusiasm/curiosity to dive in.

- 3/5 Fortran
- 3/5 COBOL
- 5/5 Common Lisp
- 3/5 C
- 3/5 Pascal
- 2/5 Modula
- 3/5 Ada
- 2/5 Simula
- 5/5 Smalltalk
- 3.5/5 ML/OCaml
- 5/5 Erlang/Elixir (primarily interested in actor model as a native language
  feature)
- 5/5 Haskell
- 5/5 Rust
- 3/5 Julia
- 3/5 R
